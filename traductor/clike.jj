//*****************************************************************
// File:   clike.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
//         Pablo Cervera López (815538)
//         Diego Domingo Ralla (818637)
// Date:   Marzo 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
 	IGNORE_CASE = false;
 	COMMON_TOKEN_ACTION = false;
 	// DEBUG_PARSER = true;
 	// ERROR_REPORTING = false;
}

PARSER_BEGIN(clike)

package traductor;

import java.util.ArrayList;

import lib.attributes.Attributes;
import lib.errores.ErrorSemantico;
import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;

public class clike {

    static SymbolTable st;
    static ErrorSemantico errSem;

    public static void main(String[] args) {
    	clike parser = null;
        st = new SymbolTable();
        errSem = new ErrorSemantico();
    	try {
	    	if (args.length == 0) {
				parser = new clike(System.in);
			}
			else {
	            parser = new clike(new java.io.FileInputStream(args[0]));
			}
			// Programa es el símbolo inicial de la gramática
			parser.Programa();
			System.out.println("***** Análisis terminado con éxito *****");
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
		catch (ParseException e) {
			System.err.println("PARSER_ERROR: " + e.getMessage());
		}
    }
    
}

PARSER_END(clike)

SKIP : {
	" "
|	"\n"
|   "\t"
|   "\r"
|   < "//" (~["\r", "\n"])* >
}

TOKEN : {
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|   < #TOK: ~[] >
}

TOKEN : {
    < tBOOL: "bool" >
|	< tCHAR: "char" >
|	< tINT: "int" >
|	< tVOID: "void" >
|	< tIF: "if" >
|	< tWHILE: "while" >
|	< tELSE: "else" >
|   < tPRINT: "print" >
|   < tPRINTLN: "print_ln" >
|   < tREAD: "read" >
|   < tREADLN: "read_ln" >
|   < tRET: "return" >
|	< tPC: ";" >
|	< tC: "," >
|	< tAMP: "&" >
|	< tAP: "(" >
|	< tCP: ")" >
|   < tAC: "[" >
|   < tCC: "]" >
|	< tAL: "{" >
|	< tCL: "}" >
|	< tAS: "=" >
|   < tIG: "==" >
|   < tDIS: "!=" >
|   < tMAY: ">" >
|   < tMEN: "<" >
|   < tMAY_IG: ">=" >
|   < tMEN_IG: "<=" >
|   < tOR: "||" >
|   < tAND: "&&" >
|   < tNOT: "!" >
|   < tSUM: "+" >
|   < tRES: "-" >
|   < tMUL: "*" >
|   < tDIV: "/" >
|   < tMOD: "%" >
|   < tSTRING : "\"" (~["\""])* "\"" >
|   < tINT2CHAR: "int2char" >
|   < tCHAR2INT: "char2int" >
|   < tTRUE: "true" >
|   < tFALSE: "false" >
|   < tCONST_CHAR: "\'" <TOK> "\'" >
|	< tCONST_INT: (<DIGIT>)+ >
|   < tID: <LETTER>(<LETTER>|<DIGIT>|"_")* >
}

SPECIAL_TOKEN : {
    < tBASURA: ~[] >
        {
            System.out.println("ERROR LÉXICO: (" + matchedToken.beginLine +
            ", " + matchedToken.beginColumn + "): símbolo no reconocido: \"" +
            matchedToken.image + "\"");
        }
}

//------------ Símbolo inicial de la gramática
void Programa() :
{
    Attributes at = new Attributes();
}
{
	(declaracion(at))+
	< EOF >
}

void declaracion(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
	LOOKAHEAD(3)
	declaracion_variables(at1) < tPC >
|   declaracion_func_proc(at1)
}

void declaracion_variables(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    tipo(at1)
    { at2.type = at1.type; }
    lista_vars(at2)
}

void variable(Attributes at) :
{
    Token t1, t2;
}
{
    LOOKAHEAD(2)
    t1 = < tID >
    < tAC >
    t2 = < tCONST_INT >
    < tCC >
    {
        Symbol s = null;
        if (at.parClass == Symbol.ParameterClass.VAL || at.parClass == Symbol.ParameterClass.REF) {
            s = new SymbolArray(t1.image, 0, Integer.parseInt(t2.image)-1,
                                at.type, at.parClass);
            at.parList.add(s);
        }
        else {
            s = new SymbolArray(t1.image, 0, Integer.parseInt(t2.image)-1,
                                at.type);
        }
        try {
            st.insertSymbol(s);
        }
        catch (AlreadyDefinedSymbolException e){
            errSem.deteccion(e, t1);
        }
        at.code = t1.image + "[" + t2.image + "]";
    }
|   t1 = < tID >
    {
        Symbol s = null;
        if (at.parClass == Symbol.ParameterClass.VAL || at.parClass == Symbol.ParameterClass.REF) {
            if (at.type == Symbol.Types.INT) {
                s = new SymbolInt(t1.image, at.parClass);
            }
            else if (at.type == Symbol.Types.CHAR) {
                s = new SymbolChar(t1.image, at.parClass);
            }
            else {
                s = new SymbolBool(t1.image, at.parClass);
            }
            at.parList.add(s);
        }
        else {  
            if (at.type == Symbol.Types.INT) {
                s = new SymbolInt(t1.image);
            }
            else if (at.type == Symbol.Types.CHAR) {
                s = new SymbolChar(t1.image);
            }
            else {
                s = new SymbolBool(t1.image);
            }
        }
        try {
            st.insertSymbol(s);
        }
        catch (AlreadyDefinedSymbolException e) {
            errSem.deteccion(e, t1);
        }
        at.code = t1.image;
    }
}

void lista_vars(Attributes at) :
{
    Attributes at1 = new Attributes();
    at1.type = at.type; 
}
{
    variable(at1)
    (
        < tC >
        variable(at1)
    )*
}

void declaracion_func_proc(Attributes at) :
{
    Token t;
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    tipo(at1)
    t = < tID >
    {
        Symbol s = null;
        at.parList = new ArrayList<Symbol>();
        if (at1.type == Symbol.Types.PROCEDURE) {
            s = new SymbolProcedure(t.image, at.parList);
        }
        else {
            s = new SymbolFunction(t.image, at.parList, at1.type);
        }
        try {
            st.insertSymbol(s);
            at.nivel = s.nivel;
            at2.name = s.name;
        }
        catch (AlreadyDefinedSymbolException e) {
            errSem.deteccion(e, t);
        }
        st.insertBlock();
        at2.parList = at.parList;
        at2.type = at1.type;
    }
    resto_declaracion_func_proc(at2)
    {
        if (at1.type == Symbol.Types.PROCEDURE) {
            ((SymbolProcedure) s).parList = at2.parList;
        } 
        else {
            ((SymbolFunction) s).parList = at2.parList;
        }
    }
}

void resto_declaracion_func_proc(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
    at1.parList = at.parList;
    at3.type = at.type;
    at3.name = at.name;
}
{
    < tAP >
    (lista_params(at1))?
    { at.parList = at1.parList; }
    < tCP >
    < tAL >
    (declaracion_variables(at2) < tPC >)*
    (instruccion(at3))+
    < tCL >
    {
        System.err.println(st.toString());
        st.removeBlock();
    }
}

void parametro(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
}
{
    tipo(at1)
    (referencia(at2))?
    { 
        at3.type = at1.type;
        if (at2.parClass != Symbol.ParameterClass.REF) {
            at3.parClass = Symbol.ParameterClass.VAL;
        }
        else {
            at3.parClass = at2.parClass;
        }
        at3.parList = at.parList;  
    }
    variable(at3)
    { at.parList = at3.parList; }
}

void referencia(Attributes at) :
{

}
{
    < tAMP >
    { at.parClass = Symbol.ParameterClass.REF; }
}

void lista_params(Attributes at) :
{
    Attributes at1 = new Attributes();
    at1.parList = at.parList;
    at1.type = at.type;
    at1.name = at.name;
}
{
    parametro(at1)
    (
        < tC >
        parametro(at1)
    )*
    { at.parList = at1.parList; }
}

void instruccion(Attributes at) :
{
    Attributes at1 = new Attributes();
    at1.type = at.type;
    at1.name = at.name;
}
{
    inst_leer(at1) < tPC >
|   inst_leer_linea(at1) < tPC >
|   inst_escribir(at1) < tPC >
|   inst_escribir_linea(at1) < tPC >
|   LOOKAHEAD(2) inst_invoc_proc(at1) < tPC >
|   inst_asignacion(at1) < tPC >
|   inst_seleccion(at1)
|   inst_iteracion(at1)
|   inst_return(at1) < tPC >
}

void inst_escribir(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    < tPRINT > < tAP > lista_una_o_mas_exps(at1) < tCP >
}

void inst_escribir_linea(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    < tPRINTLN > < tAP > lista_cero_o_mas_exps(at) < tCP >
}

void inst_leer(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    < tREAD > < tAP > lista_uno_o_mas_asignables(at1) < tCP >
}

void inst_leer_linea(Attributes at) :
{
    
}
{
    < tREADLN > < tAP > lista_cero_o_mas_asignables(at) < tCP >
}

void inst_asignacion(Attributes at) :
{
    Token t;
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    asignable(at1)
    t = < tAS >
    expresion(at2)
    {
        Symbol s = null;
        try {
            s = st.getSymbol(at1.name);
            if (at1.type != Symbol.Types.INT && at1.type != Symbol.Types.BOOL && at1.type != Symbol.Types.CHAR && !at1.isCompVector) { 
                errSem.deteccion("No se pueden asignar ARRAY enteras", t);
            }
            if (at1.type != at2.type) {
                errSem.deteccion("Tipos incompatibles en asignación: " + at1.type.name() + "/" + at2.type.name(), t);
            }
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
    }
}

void expresion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    relacion(at1)
    { 
        at.type = at1.type;
        at.name = at1.name;
        at.beginLine = at1.beginLine;
        at.beginColumn = at1.beginColumn;
        at2.type = at1.type;
    }
    (mas_relacion(at2))?
}

void mas_relacion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    (
        and_or(at1) 
        relacion(at2)
        {
            if (at.type != at2.type) {
                errSem.deteccion("Tipos incompatibles en expresión: " + at.type.name() + "/" + at2.type.name(), at2);
            }
            if (at2.type != Symbol.Types.BOOL) {
                errSem.deteccion("Tipos imcompatibles en expresión: BOOL/" + at2.type.name(), at2);
            }
        }
    )+
}

void and_or(Attributes at) :
{

}
{
    < tOR >
|   < tAND >
}

// relacion: expresion_simple (operador_relacional expresion_simple)?
void relacion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
}
{
    expresion_simple(at1)
    {
        at.isConst = at1.isConst;
        at.isVar = at1.isVar;
        at.type = at1.type;
        at.name = at1.name;
        at.beginColumn = at1.beginColumn;
        at.beginLine = at1.beginLine;
    }
    (
        operador_relacional(at2)
        expresion_simple(at3)
        {
            if (at1.type == at3.type) {
                at.type = Symbol.Types.BOOL;
            }
            else {
                at.type = Symbol.Types.UNDEFINED;
                errSem.deteccion("Tipos incompatibles en expresión: " + at1.type.name() + "/" + at3.type.name(), at3);
            }
            at.isVar = false;
            at.name = at3.name;
            at.beginColumn = at3.beginColumn;
            at.beginLine = at3.beginLine;
        }
    )?
}

void operador_relacional(Attributes at) :
{

}
{
    < tIG >
|   < tMEN >
|   < tMAY >
|   < tMEN_IG >
|   < tMAY_IG >
|   < tDIS >
}

void expresion_simple(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
    Attributes at4 = new Attributes();
}
{
    (
        op_MAS_MENOS(at1)
    )?
    termino(at2)
    { 
        at.type = at2.type; 
        at.beginLine = at2.beginLine;
        at.beginColumn = at2.beginColumn;
        at.name = at2.name;
    }
    (
        op_MAS_MENOS(at3)
        termino(at4)
        {
            if (at2.type == at4.type && at2.type == Symbol.Types.INT) {
                at.type = at4.type;
                at.name = at4.name;
                at.beginLine = at4.beginLine;
                at.beginColumn = at4.beginColumn;
            }
            else {
                if (at2.type != Symbol.Types.INT) {
                    errSem.deteccion("Tipos incompatibles en expresión: " + at2.type.name() + "/INT/" + at4.type.name(), at2);
                }
                else {
                    errSem.deteccion("Tipos incompatibles en expresión: " + at2.type.name() + "/INT/" + at4.type.name(), at4);
                }
            }
        }
    )*
}

void op_MAS_MENOS(Attributes at) :
{

}
{
    < tSUM >
|   < tRES >
}

void termino(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
}
{
    factor(at1)
    { 
        at.type = at1.type; 
        at.name = at1.name;
        at.beginLine = at1.beginLine;
        at.beginColumn = at1.beginColumn;
    }
    (
        op_MULT(at2)
        factor(at3)
        {
            if (at1.type == at3.type && at1.type == Symbol.Types.INT) {
                at.type = at3.type;
                at.name = at3.name;
                at.beginLine = at3.beginLine;
                at.beginColumn = at3.beginColumn;
            }
            else {
                if (at1.type != Symbol.Types.INT) {
                    errSem.deteccion("Tipos incompatibles en expresión: " + at1.type.name() + "/INT/" + at3.type.name(), at1);
                }
                else {
                    errSem.deteccion("Tipos incompatibles en expresión: " + at1.type.name() + "/INT/" + at3.type.name(), at3);
                }
            }
        }
    )*
}

void op_MULT(Attributes at) :
{

}
{
    < tMUL >
|   < tDIV >
|   < tMOD >
}

void factor(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    primario(at1)
    { 
        at.type = at1.type;
        at.name = at1.name;
        at.beginLine = at1.beginLine;
        at.beginColumn = at1.beginColumn;
    }
|   < tNOT >
    primario(at1)
    { 
        at.type = at1.type;
        at.name = at1.name;
        at.beginLine = at1.beginLine;
        at.beginColumn = at1.beginColumn;
    }
}

void primario(Attributes at) :
{
    Token t;
    Attributes at1 = new Attributes();
}
{
    < tAP > expresion(at1) < tCP >
|   < tINT2CHAR > < tAP > expresion(at1) < tCP >
|   < tCHAR2INT > < tAP > expresion(at1) < tCP >
|   LOOKAHEAD(2) t = < tID > < tAP > lista_cero_o_mas_exps(at) < tCP >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            if (!(s instanceof SymbolFunction)) {
                errSem.deteccion("Tiene que ser una invocación a función", t);
            }
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        at.isVar = false;
        at.type = ((SymbolFunction) s).returnType;
        // Procesar la lista de parámetros reales...
        // ...
    }
|   LOOKAHEAD(2) t = < tID > < tAC > expresion(at1) < tCC >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            if (at1.type != Symbol.Types.INT) {
                errSem.deteccion("El selector de un array debe ser de tipo entero", t);
            }
            at.name = s.name;  
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        at.isCompVector = true;
        at.type = ((SymbolArray) s).baseType;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
    }
|   t = < tID >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        at.isVar = true;
        at.type = s.type;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
|   t = < tCONST_INT >
    {
        at.type = Symbol.Types.INT;
        at.isVar = false;
        at.isConst = true;
        at.valInt = Integer.parseInt(t.image);
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
|   t = < tCONST_CHAR >
    {
        at.type = Symbol.Types.CHAR;
        at.isVar = false;
        at.isConst = true;
        at.valChar = t.image.charAt(0);
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
|   t = < tSTRING >
    {
        at.type = Symbol.Types.STRING;
        at.isVar = false;
        at.isConst = true;
        at.valString = t.image;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
|   t = < tTRUE >
    {
        at.type = Symbol.Types.BOOL;
        at.isVar = false;
        at.isConst = true;
        at.valBool = true;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
|   t = < tFALSE >
    {
        at.type = Symbol.Types.BOOL;
        at.isVar = false;
        at.isConst = true;
        at.valBool = false;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
}

void asignable(Attributes at) :
{
    Token t;
    Attributes at1 = new Attributes();
}
{
    LOOKAHEAD(2) t = < tID > < tAC > expresion(at1) < tCC >
    { 
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            if (at1.type != Symbol.Types.INT) {
                errSem.deteccion("El selector de un array debe ser de tipo INT", t);
            }
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        at.isVar = true;
        at.isCompVector = true; 
        at.isConst = false;
        at.name = t.image;
        at.type = ((SymbolArray) s).baseType;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
    }
|   t = < tID >
    { 
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            at.name = s.name;
            at.type = s.type;
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        
        at.isVar = true;
        at.isCompVector = false; 
        at.isConst = false;
        at.name = t.image;
        at.type = s.type;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
    }
}

void tipo(Attributes at) :
{

}
{
    < tINT >
    { at.type = Symbol.Types.INT; }
|   < tCHAR >
    { at.type = Symbol.Types.CHAR; }
|   < tBOOL >
    { at.type = Symbol.Types.BOOL; }
|   < tVOID >
    { at.type = Symbol.Types.PROCEDURE; }
}

void inst_invoc_proc(Attributes at) :
{
    Token t;
}
{
    t = < tID > 
    < tAP > 
    lista_cero_o_mas_exps(at) 
    < tCP >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            // Error si se invoca a main
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        // Analizar parámetros reales con parámetros formales
    }
}

void inst_seleccion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
    at2.type = at.type;
    at2.name = at.name;
    at3.type = at.type;
    at3.name = at.name;
}
{
    < tIF > 
    < tAP >
    expresion(at1) 
    {
        if (at1.type != Symbol.Types.BOOL) {
            errSem.deteccion("La condición de un 'if' debe ser tipo 'boolean'", at1);
        }
    }
    < tCP >
    < tAL > 
    (instruccion(at2))* 
    < tCL >
    (bloque_else(at3))?
}

void bloque_else(Attributes at) :
{
    Attributes at1 = new Attributes();
    at1.type = at.type;
    at1.name = at.name;
}
{
    < tELSE > 
    < tAL > 
    (instruccion(at1))*
    < tCL >
}

void inst_iteracion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    at2.type = at.type;
    at2.name = at.name;
}
{
    < tWHILE > 
    < tAP >
    expresion(at1) 
    {
        if (at1.type != Symbol.Types.BOOL) {
            errSem.deteccion("La condición de un 'while' debe ser de tipo 'boolean'", at1);
        }
    }
    < tCP >
    < tAL > 
    (instruccion(at2))* 
    < tCL >
}

void inst_return(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    < tRET > expresion(at1)
    {
        if (at.type != at1.type) {
            errSem.deteccion("Instrucción return de la función " + at.name + " con tipo de dato incompatible: " + at.type.name() + "/" + at1.type.name(), at1);
        }
    }
}

void lista_cero_o_mas_exps(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    (lista_una_o_mas_exps(at1))?
    {
        // Supongo que habrá que propagarlo hacia arriba
        at.lExps = at1.lExps;
    }
}

void lista_una_o_mas_exps(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    expresion(at1)
    { at.lExps.add(at1); }
    (
        < tC >
        expresion(at2)
        { at.lExps.add(at2); }
    )*
}

void lista_cero_o_mas_asignables(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    (lista_uno_o_mas_asignables(at1))?
    {
        at.type = at1.type;
        at.name = at1.name;
        at.beginColumn = at1.beginColumn;
        at.beginLine = at1.beginLine;
    }

}

void lista_uno_o_mas_asignables(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    asignable(at1)
    {
        if (at1.type != Symbol.Types.CHAR && at1.type != Symbol.Types.INT) {
            errSem.deteccion("No se admite un argumento " + at1.type.name() + " en un 'read'", at1);
        }
        else {
            at.type = at1.type;
            at.name = at1.name;
            at.beginColumn = at1.beginColumn;
            at.beginLine = at1.beginLine;
        }
    }
    (
        < tC >
        asignable(at2) {
            if (at1.type != Symbol.Types.CHAR && at1.type != Symbol.Types.INT) {
                errSem.deteccion("No se admite un argumento " + at2.type.name() + " en un 'read'", at2);
            }
            else {
                at.type = at2.type;
                at.name = at2.name;
                at.beginColumn = at2.beginColumn;
                at.beginLine = at2.beginLine;
            }
        }
    )*
}
