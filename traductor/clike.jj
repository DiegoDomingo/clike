//*****************************************************************
// File:   clike.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
//         Pablo Cervera López (815538)
//         Diego Domingo Ralla (818637)
// Date:   Marzo 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
 	IGNORE_CASE = false;
 	COMMON_TOKEN_ACTION = false;
 	// DEBUG_PARSER = true;
 	// ERROR_REPORTING = false;
}

PARSER_BEGIN(clike)

package traductor;

import java.util.ArrayList;

import lib.attributes.Attributes;
import lib.errores.ErrorSemantico;
import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;

public class clike {

    static SymbolTable st;
    static ErrorSemantico errSem;

    public static void main(String[] args) {
    	clike parser = null;
        st = new SymbolTable();
        errSem = new ErrorSemantico();
    	try {
	    	if (args.length == 0) {
				parser = new clike(System.in);
			}
			else {
	            parser = new clike(new java.io.FileInputStream(args[0]));
			}
			// Programa es el símbolo inicial de la gramática
			parser.Programa();
			System.out.println("***** Análisis terminado con éxito *****");
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
		catch (ParseException e) {
			System.out.println("PARSER_ERROR: " + e.getMessage());
		}
    }
    
}

PARSER_END(clike)

SKIP : {
	" "
|	"\n"
|   "\t"
|   "\r"
|   < "//" (~["\r", "\n"])* >
}

TOKEN : {
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|   < #TOK: ~[] >
}

TOKEN : {
    < tBOOL: "bool" >
|	< tCHAR: "char" >
|	< tINT: "int" >
|	< tVOID: "void" >
|	< tIF: "if" >
|	< tWHILE: "while" >
|	< tELSE: "else" >
|   < tPRINT: "print" >
|   < tPRINTLN: "print_ln" >
|   < tREAD: "read" >
|   < tREADLN: "read_ln" >
|   < tRET: "return" >
|	< tPC: ";" >
|	< tC: "," >
|	< tAMP: "&" >
|	< tAP: "(" >
|	< tCP: ")" >
|   < tAC: "[" >
|   < tCC: "]" >
|	< tAL: "{" >
|	< tCL: "}" >
|	< tAS: "=" >
|   < tIG: "==" >
|   < tDIS: "!=" >
|   < tMAY: ">" >
|   < tMEN: "<" >
|   < tMAY_IG: ">=" >
|   < tMEN_IG: "<=" >
|   < tOR: "||" >
|   < tAND: "&&" >
|   < tNOT: "!" >
|   < tSUM: "+" >
|   < tRES: "-" >
|   < tMUL: "*" >
|   < tDIV: "/" >
|   < tMOD: "%" >
|   < tSTRING : "\"" (~["\""])* "\"" >
|   < tINT2CHAR: "int2char" >
|   < tCHAR2INT: "char2int" >
|   < tTRUE: "true" >
|   < tFALSE: "false" >
|   < tCONST_CHAR: "\'" <TOK> "\'" >
|	< tCONST_INT: (<DIGIT>)+ >
|   < tID: <LETTER>(<LETTER>|<DIGIT>|"_")* >
}

SPECIAL_TOKEN : {
    < tBASURA: ~[] >
        {
            System.out.println("ERROR LÉXICO: (" + matchedToken.beginLine +
            ", " + matchedToken.beginColumn + "): símbolo no reconocido: \"" +
            matchedToken.image + "\"");
        }
}

//------------ Símbolo inicial de la gramática
void Programa() :
{
    Attributes at = new Attributes();
}
{
	(declaracion(at))+
	< EOF >
}

void declaracion(Attributes at) :
{

}
{
	LOOKAHEAD(3)
	declaracion_variables(at) < tPC >
|   declaracion_func_proc(at)
}

void declaracion_variables(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    tipo(at1)
    { at2.type = at1.type; }
    lista_vars(at2)
}

void variable(Attributes at) :
{
    Token t1, t2;
}
{
    LOOKAHEAD(2)
    t1 = < tID >
    < tAC >
    t2 = < tCONST_INT >
    < tCC >
    {
        Symbol s = null;
        if (at.parClass == Symbol.ParameterClass.VAL || at.parClass == Symbol.ParameterClass.REF) {
            s = new SymbolArray(t1.image, 0, Integer.parseInt(t2.image)-1,
                                at.type, at.parClass);
            at.parList.add(s);
        }
        else {
            s = new SymbolArray(t1.image, 0, Integer.parseInt(t2.image)-1,
                                at.type);
        }
        try {
            st.insertSymbol(s);
        }
        catch (AlreadyDefinedSymbolException e){
            errSem.deteccion(e, t1);
        }
    }
|   t1 = < tID >
    {
        Symbol s = null;
        if (at.parClass == Symbol.ParameterClass.VAL || at.parClass == Symbol.ParameterClass.REF) {
            if (at.type == Symbol.Types.INT) {
                s = new SymbolInt(t1.image, at.parClass);
            }
            else if (at.type == Symbol.Types.CHAR) {
                s = new SymbolChar(t1.image, at.parClass);
            }
            else {
                s = new SymbolBool(t1.image, at.parClass);
            }
            at.parList.add(s);
        }
        else {
            if (at.type == Symbol.Types.INT) {
                s = new SymbolInt(t1.image);
            }
            else if (at.type == Symbol.Types.CHAR) {
                s = new SymbolChar(t1.image);
            }
            else {
                s = new SymbolBool(t1.image);
            }
        }
        try {
            st.insertSymbol(s);
        }
        catch (AlreadyDefinedSymbolException e) {
            errSem.deteccion(e, t1);
        }
    }
}

void lista_vars(Attributes at) :
{
    Attributes at1 = new Attributes();
    at1.type = at.type;
}
{
    variable(at1)
    (
        < tC >
        variable(at1)
    )*
}

void declaracion_func_proc(Attributes at) :
{
    Token t;
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    tipo(at1)
    t = < tID >
    {
        Symbol s = null;
        at.parList = new ArrayList<Symbol>();
        if (at1.type == Symbol.Types.PROCEDURE) {
            s = new SymbolProcedure(t.image, at.parList);
        }
        else {
            s = new SymbolFunction(t.image, at.parList, at1.type);
        }
        try {
            st.insertSymbol(s);
        }
        catch (AlreadyDefinedSymbolException e) {
            errSem.deteccion(e, t);
        }
        // at.nivel = s.nivel;
        st.insertBlock();
        at2.parList = at.parList;
    }
    resto_declaracion_func_proc(at2)
    { s.parList = at2.parList; } // FIXME:
}

void resto_declaracion_func_proc(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    < tAP >
    (lista_params(at))?
    < tCP >
    < tAL >
    (declaracion_variables(at1) < tPC >)*
    (instruccion())+
    < tCL >
}

void parametro(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    tipo(at1)
    (referencia(at1))?
    { 
        at2.type = at1.type;
        if (at1.parClass != Symbol.ParameterClass.REF) {
            at2.parClass = Symbol.ParameterClass.VAL;
        }
        else {
            at2.parClass = at1.parClass; 
        }
        at2.parList = at.parList;
    }
    variable(at2)
}

void referencia(Attributes at) :
{

}
{
    < tAMP >
    { at.parClass = Symbol.ParameterClass.REF; }
}

void lista_params(Attributes at) :
{
    Attributes at1 = new Attributes();
    at1.type = at.type;
}
{
    parametro(at1)
    (
        < tC >
        parametro(at1)
    )*
}

void instruccion() :
{

}
{
    inst_leer() < tPC >
|   inst_leer_linea() < tPC >
|   inst_escribir() < tPC >
|   inst_escribir_linea() < tPC >
|   LOOKAHEAD(2) inst_invoc_proc() < tPC >
|   inst_asignacion() < tPC >
|   inst_seleccion()
|   inst_iteracion()
|   inst_return() < tPC >
}

void inst_escribir() :
{

}
{
    < tPRINT > < tAP > lista_una_o_mas_exps() < tCP >
}

void inst_escribir_linea() :
{

}
{
    < tPRINTLN > < tAP > lista_cero_o_mas_exps() < tCP >
}

void inst_leer() :
{

}
{
    < tREAD > < tAP > lista_uno_o_mas_asignables() < tCP >
}

void inst_leer_linea() :
{

}
{
    < tREADLN > < tAP > lista_cero_o_mas_asignables() < tCP >
}

void inst_asignacion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    asignable(at1)
    < tAS >
    expresion(at2)
    {
        Symbol s = null;
        try {
            s = st.getSymbol(at1.name);
            if (at1.type != Symbol.Types.INT && at1.type != Symbol.Types.BOOL && at1.type != Symbol.Types.CHAR) { 
                throw new IncompatibleTypesException();
            }
            if (at1.type != at2.type) {
                throw new IncompatibleTypesException();
            }
        }
        catch (SymbolNotFoundException e) {
            // errSem.deteccion("El símbolo no existe");
        }
        catch (IncompatibleTypesException e) {
            // errSem.deteccion("Tipos incompatibles");
        }
    }
}

void expresion(Attributes at) :
{

}
{
    relacion()
    (mas_relacion())?
}

void mas_relacion() :
{

}
{
    (and_or() relacion())+
}

void and_or() :
{

}
{
    < tOR >
|   < tAND >
}

// relacion: expresion_simple (operador_relacional expresion_simple)?
void relacion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
}
{
    expresion_simple(at1)
    {
        at.isConst = at1.isConst;
        at.isVar = at1.isVar;
        at.type = at1.type;
        // ...
    }
    (
        operador_relacional(at2)
        expresion_simple(at3)
        {
            if (at1.type == at3.type) {
                at.type = Symbol.Types.BOOL;
            }
            else {
                at.type = Symbol.Types.UNDEFINED;
                // errSem.deteccion("Tipos incompatibles"); 
                // ...
            }
            at.isVar = false;
            // ...
        }
    )?
}

void operador_relacional(Attributes at) :
{

}
{
    < tIG >
|   < tMEN >
|   < tMAY >
|   < tMEN_IG >
|   < tMAY_IG >
|   < tDIS >
}

void expresion_simple(Attributes at) :
{

}
{
    (
        op_MAS_MENOS()
    )?
    termino()
    (
        op_MAS_MENOS()
        termino()
    )*
}

void op_MAS_MENOS() :
{

}
{
    < tSUM >
|   < tRES >
}

void termino() :
{

}
{
    factor()
    (
        op_MULT()
        factor()
    )*
}

void op_MULT() :
{

}
{
    < tMUL >
|   < tDIV >
|   < tMOD >
}

void factor(Attributes at) :
{

}
{
    primario()
|   < tNOT >
    primario()
}

void primario(Attributes at) :
{
    Token t;
}
{
    < tAP > expresion() < tCP >
|   < tINT2CHAR > < tAP > expresion() < tCP >
|   < tCHAR2INT > < tAP > expresion() < tCP >
|   LOOKAHEAD(2) t = < tID > < tAP > lista_cero_o_mas_exps() < tCP >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            if (!(s instanceof SymbolFunction)) {
                // errSem.deteccion("Se esperaba función...");
            }
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        at.isVar = false;
        at.type = ((SymbolFunction) s).returnType;
        // Procesar la lista de parámetros reales...
        // ...
    }
|   LOOKAHEAD(2) t = < tID > < tAC > expresion() < tCC >
    {
        // ...
    }
|   t = < tID >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        at.isVar = true;
        at.type = s.type;
    }
|   t = < tCONST_INT >
    {
        at.isVar = false;
        at.isConst = true;
        at.valInt = Integer.parseInt(t.image);
    }
|   t = < tCONST_CHAR >
    {
        at.isVar = false;
        at.isConst = true;
        at.valChar = t.image.charAt(0);
    }
|   t = < tSTRING >
    {
        at.isVar = false;
        at.isConst = true;
        at.valString = t.image;
    }
|   < tTRUE >
    {
        at.isVar = false;
        at.isConst = true;
        at.valBool = true;
    }
|   < tFALSE >
    {
        at.isVar = false;
        at.isConst = true;
        at.valBool = false;
    }
}

void asignable(Attributes at) :
{

}
{
    LOOKAHEAD(2) < tID > < tAC > expresion() < tCC >
|   < tID >
}

void tipo(Attributes at) :
{

}
{
    < tINT >
    { at.type = Symbol.Types.INT; }
|   < tCHAR >
    { at.type = Symbol.Types.CHAR; }
|   < tBOOL >
    { at.type = Symbol.Types.BOOL; }
|   < tVOID >
    { at.type = Symbol.Types.PROCEDURE; }
}

void inst_invoc_proc(Attributes at) :
{
    Token t;
    at.lExps = new ArrayList<Attributes>();
}
{
    t = < tID > 
    < tAP > 
    lista_cero_o_mas_exps() 
    < tCP >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            // ...
        }
        catch (SymbolNotFoundException e) {
            // ...
        }
        // Analizar parámetros reales con parámetros formales
    }
}

void inst_seleccion() :
{

}
{
    < tIF > expresion() < tAL > (instruccion())* < tCL >
    (bloque_else())?
}

void bloque_else() :
{

}
{
    < tELSE > < tAL > (instruccion())* < tCL >
}

void inst_iteracion() :
{

}
{
    < tWHILE > expresion() < tAL > (instruccion())* < tCL >
}

void inst_return(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    < tRET > expresion()
}

void lista_cero_o_mas_exps() :
{

}
{
    (lista_una_o_mas_exps())?
}

void lista_una_o_mas_exps() :
{

}
{
    expresion()
    (
        < tC >
        expresion()
    )*
}

void lista_cero_o_mas_asignables() :
{

}
{
    (lista_uno_o_mas_asignables())?
}

void lista_uno_o_mas_asignables() :
{

}
{
    asignable()
    (
        < tC >
        asignable()
    )*
}
