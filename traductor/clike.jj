//*****************************************************************
// File:   clike.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
//         Pablo Cervera López (815538)
//         Diego Domingo Ralla (818637)
// Date:   Marzo 2023
// Coms:   compilar mediante "ant"
//*****************************************************************

options {
 	IGNORE_CASE = false;
 	COMMON_TOKEN_ACTION = false;
 	// DEBUG_PARSER = true;
 	// ERROR_REPORTING = false;
}

PARSER_BEGIN(clike)

package traductor;

import java.util.ArrayList;

import lib.attributes.Attributes;
import lib.errores.ErrorSemantico;
import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.tools.SemanticFunctions;

public class clike {

    static SymbolTable st;
    static ErrorSemantico errSem;
    static SemanticFunctions sf;

    public static void main(String[] args) {
    	clike parser = null;
        st = new SymbolTable();
        errSem = new ErrorSemantico();
        sf = new SemanticFunctions();
    	try {
	    	if (args.length == 0) {
				parser = new clike(System.in);
			}
			else {
	            parser = new clike(new java.io.FileInputStream(args[0]));
			}
			// Programa es el símbolo inicial de la gramática
			parser.Programa();
			System.out.println("***** Análisis terminado con éxito *****");
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
		catch (ParseException e) {
			System.err.println("PARSER_ERROR: " + e.getMessage());
		}
    }
    
}

PARSER_END(clike)

SKIP : {
	" "
|	"\n"
|   "\t"
|   "\r"
|   < "//" (~["\r", "\n"])* >
}

TOKEN : {
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|   < #TOK: ~[] >
}

TOKEN : {
    < tBOOL: "bool" >
|	< tCHAR: "char" >
|	< tINT: "int" >
|	< tVOID: "void" >
|	< tIF: "if" >
|	< tWHILE: "while" >
|	< tELSE: "else" >
|   < tPRINT: "print" >
|   < tPRINTLN: "print_ln" >
|   < tREAD: "read" >
|   < tREADLN: "read_ln" >
|   < tRET: "return" >
|	< tPC: ";" >
|	< tC: "," >
|	< tAMP: "&" >
|	< tAP: "(" >
|	< tCP: ")" >
|   < tAC: "[" >
|   < tCC: "]" >
|	< tAL: "{" >
|	< tCL: "}" >
|	< tAS: "=" >
|   < tIG: "==" >
|   < tDIS: "!=" >
|   < tMAY: ">" >
|   < tMEN: "<" >
|   < tMAY_IG: ">=" >
|   < tMEN_IG: "<=" >
|   < tOR: "||" >
|   < tAND: "&&" >
|   < tNOT: "!" >
|   < tSUM: "+" >
|   < tRES: "-" >
|   < tMUL: "*" >
|   < tDIV: "/" >
|   < tMOD: "%" >
|   < tSTRING : "\"" (~["\""])* "\"" >
|   < tINT2CHAR: "int2char" >
|   < tCHAR2INT: "char2int" >
|   < tTRUE: "true" >
|   < tFALSE: "false" >
|   < tCONST_CHAR: "\'" <TOK> "\'" >
|	< tCONST_INT: (<DIGIT>)+ >
|   < tID: <LETTER>(<LETTER>|<DIGIT>|"_")* >
}

SPECIAL_TOKEN : {
    < tBASURA: ~[] >
        {
            System.out.println("ERROR LÉXICO: (" + matchedToken.beginLine +
            ", " + matchedToken.beginColumn + "): símbolo no reconocido: \"" +
            matchedToken.image + "\"");
        }
}

//------------ Símbolo inicial de la gramática
void Programa() :
{
    Attributes at = new Attributes();
}
{
	(declaracion(at))+
	< EOF >
}

void declaracion(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
	LOOKAHEAD(3)
	declaracion_variables(at1) < tPC >
|   declaracion_func_proc(at1)
}

void declaracion_variables(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    tipo(at1)
    { at2.type = at1.type; }
    lista_vars(at2)
}

void variable(Attributes at) :
{
    Token t1, t2;
}
{
    LOOKAHEAD(2)
    t1 = < tID >
    < tAC >
    t2 = < tCONST_INT >
    < tCC >
    { sf.variable_array(t1, t2, at, st); }
|   t1 = < tID >
    { sf.variable(t1, at, st); }
}

void lista_vars(Attributes at) :
{
    Attributes at1 = new Attributes();
    at1.type = at.type; 
}
{
    variable(at1)
    (
        < tC >
        variable(at1)
    )*
}

void declaracion_func_proc(Attributes at) :
{
    Token t;
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    tipo(at1)
    t = < tID >
    {
        Symbol s = sf.declaracion_func_proc(t, at, at1, at2, st);
    }
    resto_declaracion_func_proc(at2)
    {
        if (!t.image.contentEquals("main")) {
            if (at1.type == Symbol.Types.PROCEDURE) {
                ((SymbolProcedure) s).parList = at2.parList;
            } 
            else {
                ((SymbolFunction) s).parList = at2.parList;
            }
        }
    }
}

void resto_declaracion_func_proc(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
    at1.parList = at.parList;
    at3.type = at.type;
    at3.name = at.name;
}
{
    < tAP >
    (lista_params(at1))?
    { at.parList = at1.parList; }
    < tCP >
    < tAL >
    (declaracion_variables(at2) < tPC >)*
    (instruccion(at3))+
    < tCL >
    {
        System.err.println(st.toString());
        st.removeBlock();
    }
}

void parametro(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
}
{
    tipo(at1)
    (referencia(at2))?
    { sf.parametro(at, at1, at2, at3); }
    variable(at3)
    { at.parList = at3.parList; }
}

void referencia(Attributes at) :
{

}
{
    < tAMP >
    { at.parClass = Symbol.ParameterClass.REF; }
}

void lista_params(Attributes at) :
{
    Attributes at1 = new Attributes();
    at1.parList = at.parList;
    at1.type = at.type;
    at1.name = at.name;
}
{
    parametro(at1)
    (
        < tC >
        parametro(at1)
    )*
    { at.parList = at1.parList; }
}

void instruccion(Attributes at) :
{
    Attributes at1 = new Attributes();
    at1.type = at.type;
    at1.name = at.name;
}
{
    inst_leer(at1) < tPC >
|   inst_leer_linea(at1) < tPC >
|   inst_escribir(at1) < tPC >
|   inst_escribir_linea(at1) < tPC >
|   LOOKAHEAD(2) inst_invoc_proc(at1) < tPC >
|   inst_asignacion(at1) < tPC >
|   inst_seleccion(at1)
|   inst_iteracion(at1)
|   inst_return(at1) < tPC >
}

void inst_escribir(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    < tPRINT > < tAP > lista_una_o_mas_exps(at1) < tCP >
}

void inst_escribir_linea(Attributes at) :
{
    
}
{
    < tPRINTLN > < tAP > lista_cero_o_mas_exps(at) < tCP >
}

void inst_leer(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    < tREAD > < tAP > lista_uno_o_mas_asignables(at1) < tCP >
}

void inst_leer_linea(Attributes at) :
{
    
}
{
    < tREADLN > < tAP > lista_cero_o_mas_asignables(at) < tCP >
}

void inst_asignacion(Attributes at) :
{
    Token t;
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    asignable(at1)
    t = < tAS >
    expresion(at2)
    {
        Symbol s = null;
        try {
            s = st.getSymbol(at1.name);
            if (at1.type != Symbol.Types.INT && at1.type != Symbol.Types.BOOL && at1.type != Symbol.Types.CHAR && !at1.isCompVector) { 
                errSem.deteccion("No se pueden asignar ARRAY enteras", t);
            }
            if (at1.type != at2.type) {
                errSem.deteccion("Tipos incompatibles en asignación: " + at1.type.name() + "/" + at2.type.name(), t);
            }
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
    }
}

void expresion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    relacion(at1)
    { sf.expresion(at, at1, at2); }
    (mas_relacion(at2))?
}

void mas_relacion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    (
        and_or(at1) 
        relacion(at2)
        {
            if (at.type != at2.type) {
                errSem.deteccion("Tipos incompatibles en expresión: " + at.type.name() + "/" + at2.type.name(), at2);
            }
            if (at2.type != Symbol.Types.BOOL) {
                errSem.deteccion("Tipos imcompatibles en expresión: BOOL/" + at2.type.name(), at2);
            }
        }
    )+
}

void and_or(Attributes at) :
{

}
{
    < tOR >
|   < tAND >
}

// relacion: expresion_simple (operador_relacional expresion_simple)?
void relacion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
}
{
    expresion_simple(at1)
    { sf.relacion1(at, at1, at2); }
    (
        operador_relacional(at2)
        expresion_simple(at3)
        { sf.relacion2(at, at1, at2, at3); }
    )?
}

void operador_relacional(Attributes at) :
{

}
{
    < tIG >
|   < tMEN >
|   < tMAY >
|   < tMEN_IG >
|   < tMAY_IG >
|   < tDIS >
}

void expresion_simple(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
    Attributes at4 = new Attributes();
}
{
    (
        op_MAS_MENOS(at1)
    )?
    termino(at2)
    { sf.expresion_simple1(at, at2); }
    (
        op_MAS_MENOS(at3)
        termino(at4)
        { sf.expresion_simple2(at, at2, at4); }
    )*
}

void op_MAS_MENOS(Attributes at) :
{

}
{
    < tSUM >
|   < tRES >
}

void termino(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
}
{
    factor(at1)
    { 
        at.type = at1.type; 
        at.name = at1.name;
        at.beginLine = at1.beginLine;
        at.beginColumn = at1.beginColumn;
        at.arraySize = at1.arraySize;
        at.isCompVector = at1.isCompVector;
        at.isVar = at1.isVar;
        at.isConst = at1.isConst;
        at.baseType = at1.baseType;
    }
    (
        op_MULT(at2)
        factor(at3)
        {
            if (at1.type == at3.type && at1.type == Symbol.Types.INT) {
                at.type = at3.type;
                at.name = at3.name;
                at.beginLine = at3.beginLine;
                at.beginColumn = at3.beginColumn;
                at.arraySize = at3.arraySize;
                at.isCompVector = at3.isCompVector;
                at.isVar = at3.isVar;
                at.isConst = at3.isConst;
                at.baseType = at3.baseType;
            }
            else {
                if (at1.type != Symbol.Types.INT) {
                    errSem.deteccion("Tipos incompatibles en expresión: " + at1.type.name() + "/INT/" + at3.type.name(), at1);
                }
                else {
                    errSem.deteccion("Tipos incompatibles en expresión: " + at1.type.name() + "/INT/" + at3.type.name(), at3);
                }
            }
        }
    )*
}

void op_MULT(Attributes at) :
{

}
{
    < tMUL >
|   < tDIV >
|   < tMOD >
}

void factor(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    primario(at1)
    { 
        at.type = at1.type;
        at.name = at1.name;
        at.beginLine = at1.beginLine;
        at.beginColumn = at1.beginColumn;
        at.arraySize = at1.arraySize;
        at.isCompVector = at1.isCompVector;
        at.isVar = at1.isVar;
        at.isConst = at1.isConst;
        at.baseType = at1.baseType;
    }
|   < tNOT >
    primario(at1)
    { 
        at.type = at1.type;
        at.name = at1.name;
        at.beginLine = at1.beginLine;
        at.beginColumn = at1.beginColumn;
        at.arraySize = at1.arraySize;
        at.isCompVector = at1.isCompVector;
        at.isVar = at1.isVar;
        at.isConst = at1.isConst;
        at.baseType = at1.baseType;
    }
}

void primario(Attributes at) :
{
    Token t;
    Attributes at1 = new Attributes();
}
{
    < tAP > expresion(at1) < tCP >
    {
        at.type = at1.type;
        at.name = at1.name;
        at.beginLine = at1.beginLine;
        at.beginColumn = at1.beginColumn;
        at.arraySize = at1.arraySize;
        at.isCompVector = at1.isCompVector;
        at.isVar = at1.isVar;
        at.isConst = at1.isConst;
        at.baseType = at1.baseType;
    }
|   < tINT2CHAR > < tAP > expresion(at1) < tCP >
    {
        if (at1.type != Symbol.Types.INT) {
            errSem.deteccion("'int2char' requiere una expresión 'int'", at1);
            at.type = Symbol.Types.UNDEFINED;
        }
        else {
            at.type = Symbol.Types.CHAR;
        }
        at.name = at1.name;
        at.beginLine = at1.beginLine;
        at.beginColumn = at1.beginColumn;
        at.arraySize = at1.arraySize;
        at.isCompVector = at1.isCompVector;
        at.isVar = at1.isVar;
        at.isConst = at1.isConst;
        at.baseType = at1.baseType;
    }
|   < tCHAR2INT > < tAP > expresion(at1) < tCP >
    {
        if (at1.type != Symbol.Types.CHAR) {
            errSem.deteccion("'char2int' requiere una expresión 'character'", at1);
            at.type = Symbol.Types.UNDEFINED;
        }
        else {
            at.type = Symbol.Types.INT;
        }
        at.name = at1.name;
        at.beginLine = at1.beginLine;
        at.beginColumn = at1.beginColumn;
        at.arraySize = at1.arraySize;
        at.isCompVector = at1.isCompVector;
        at.isVar = at1.isVar;
        at.isConst = at1.isConst;
        at.baseType = at1.baseType;
    }
|   LOOKAHEAD(2) t = < tID > < tAP > lista_cero_o_mas_exps(at) < tCP >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            if (!(s instanceof SymbolFunction)) {
                errSem.deteccion("Tiene que ser una invocación a función", t);
            }
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        at.isVar = false;
        at.type = ((SymbolFunction) s).returnType;
        ArrayList<Symbol> parametros = ((SymbolFunction) s).parList;
        if (parametros.size() != at.lExps.size()) {
            errSem.deteccion("Diferente número de parámetros reales y formales", t);
        }
        else {
            for (int i = 0; i < at.lExps.size() && i < parametros.size(); i++) {
                if (at.lExps.get(i).type != parametros.get(i).type) {
                    errSem.deteccion("Incompatibilidad de tipos entre parámetro formal y real", t);
                }
                else {
                    if (parametros.get(i).parClass == Symbol.ParameterClass.REF) {
                        if (!at.lExps.get(i).isVar && !at.lExps.get(i).isCompVector) {
                            errSem.deteccion("El parámetro real para un paso por referencia tiene que ser un asignable", t);
                        }
                    }
                    if (parametros.get(i).type == Symbol.Types.ARRAY) {
                        if (((SymbolArray) parametros.get(i)).baseType != at.lExps.get(i).baseType) {
                            errSem.deteccion("Incompatibilidad de tipos entre parámetro formal y real", t);
                        }
                        if (((SymbolArray) parametros.get(i)).maxInd+1 != at.lExps.get(i).arraySize) {
                            errSem.deteccion("El parámetro real tiene que ser un vector compatible con el formal", t);
                        }
                    }
                }
            }
        }
    }
|   LOOKAHEAD(2) t = < tID > < tAC > expresion(at1) < tCC >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            if (at1.type != Symbol.Types.INT) {
                errSem.deteccion("El selector de un array debe ser de tipo entero", t);
            }
            at.name = s.name;  
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        at.isCompVector = true;
        at.isVar = true;
        at.isConst = false;
        at.type = ((SymbolArray) s).baseType;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
    }
|   t = < tID >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        if (s.type == Symbol.Types.ARRAY) {
            at.arraySize = ((SymbolArray) s).maxInd + 1;
            at.baseType = ((SymbolArray) s).baseType;
        }
        at.type = s.type;
        at.isVar = true;
        at.isCompVector = false;
        at.isConst = false;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
|   t = < tCONST_INT >
    {
        at.type = Symbol.Types.INT;
        at.isVar = false;
        at.isCompVector = false;
        at.isConst = true;
        at.valInt = Integer.parseInt(t.image);
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
|   t = < tCONST_CHAR >
    {
        at.type = Symbol.Types.CHAR;
        at.isVar = false;
        at.isCompVector = false;
        at.isConst = true;
        at.valChar = t.image.charAt(0);
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
|   t = < tSTRING >
    {
        at.type = Symbol.Types.STRING;
        at.isVar = false;
        at.isCompVector = false;
        at.isConst = true;
        at.valString = t.image;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
|   t = < tTRUE >
    {
        at.type = Symbol.Types.BOOL;
        at.isVar = false;
        at.isCompVector = false;
        at.isConst = true;
        at.valBool = true;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
|   t = < tFALSE >
    {
        at.type = Symbol.Types.BOOL;
        at.isVar = false;
        at.isCompVector = false;
        at.isConst = true;
        at.valBool = false;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
        at.name = t.image;
    }
}

void asignable(Attributes at) :
{
    Token t;
    Attributes at1 = new Attributes();
}
{
    LOOKAHEAD(2) t = < tID > < tAC > expresion(at1) < tCC >
    { 
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            if (at1.type != Symbol.Types.INT) {
                errSem.deteccion("El selector de un array debe ser de tipo INT", t);
            }
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        at.isVar = true;
        at.isCompVector = true; 
        at.isConst = false;
        at.name = t.image;
        at.type = ((SymbolArray) s).baseType;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
    }
|   t = < tID >
    { 
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            at.name = s.name;
            at.type = s.type;
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        
        at.isVar = true;
        at.isCompVector = false; 
        at.isConst = false;
        at.name = t.image;
        at.type = s.type;
        at.beginLine = t.beginLine;
        at.beginColumn = t.beginColumn;
    }
}

void tipo(Attributes at) :
{

}
{
    < tINT >
    { at.type = Symbol.Types.INT; }
|   < tCHAR >
    { at.type = Symbol.Types.CHAR; }
|   < tBOOL >
    { at.type = Symbol.Types.BOOL; }
|   < tVOID >
    { at.type = Symbol.Types.PROCEDURE; }
}

void inst_invoc_proc(Attributes at) :
{
    Token t;
}
{
    t = < tID > 
    < tAP > 
    lista_cero_o_mas_exps(at) 
    < tCP >
    {
        Symbol s = null;
        try {
            s = st.getSymbol(t.image);
            if (s.name.contentEquals("main")) {
                errSem.deteccion("No se puede invocar a 'main'", t);
            }
        }
        catch (SymbolNotFoundException e) {
            errSem.deteccion(e, t);
        }
        ArrayList<Symbol> parametros = ((SymbolProcedure) s).parList;
        if (parametros.size() != at.lExps.size()) {
            errSem.deteccion("Diferente número de parámetros reales y formales", t);
        }
        else {
            for (int i = 0; i < at.lExps.size() && i < parametros.size(); i++) {
                if (at.lExps.get(i).type != parametros.get(i).type) {
                    errSem.deteccion("Incompatibilidad de tipos entre parámetro formal y real", t);
                }
                else {
                    if (parametros.get(i).parClass == Symbol.ParameterClass.REF) {
                        if (!at.lExps.get(i).isVar && !at.lExps.get(i).isCompVector) {
                            errSem.deteccion("El parámetro real para un paso por referencia tiene que ser un asignable", t);
                        }
                    }
                    if (parametros.get(i).type == Symbol.Types.ARRAY) {
                        if (((SymbolArray) parametros.get(i)).baseType != at.lExps.get(i).baseType) {
                            errSem.deteccion("Incompatibilidad de tipos entre parámetro formal y real", t);
                        }
                        if (((SymbolArray) parametros.get(i)).maxInd+1 != at.lExps.get(i).arraySize) {
                            errSem.deteccion("El parámetro real tiene que ser un vector compatible con el formal", t);
                        }
                    }
                }
            }
        }
    }
}

void inst_seleccion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    Attributes at3 = new Attributes();
    at2.type = at.type;
    at2.name = at.name;
    at3.type = at.type;
    at3.name = at.name;
}
{
    < tIF > 
    < tAP >
    expresion(at1) 
    {
        if (at1.type != Symbol.Types.BOOL) {
            errSem.deteccion("La condición de un 'if' debe ser tipo 'boolean'", at1);
        }
    }
    < tCP >
    < tAL > 
    (instruccion(at2))* 
    < tCL >
    (bloque_else(at3))?
}

void bloque_else(Attributes at) :
{
    Attributes at1 = new Attributes();
    at1.type = at.type;
    at1.name = at.name;
}
{
    < tELSE > 
    < tAL > 
    (instruccion(at1))*
    < tCL >
}

void inst_iteracion(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
    at2.type = at.type;
    at2.name = at.name;
}
{
    < tWHILE > 
    < tAP >
    expresion(at1) 
    {
        if (at1.type != Symbol.Types.BOOL) {
            errSem.deteccion("La condición de un 'while' debe ser de tipo 'boolean'", at1);
        }
    }
    < tCP >
    < tAL > 
    (instruccion(at2))* 
    < tCL >
}

void inst_return(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    < tRET > expresion(at1)
    {
        if (at.type != at1.type) {
            errSem.deteccion("Instrucción return de la función " + at.name + " con tipo de dato incompatible: " + at.type.name() + "/" + at1.type.name(), at1);
        }
    }
}

void lista_cero_o_mas_exps(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    (lista_una_o_mas_exps(at1))?
    {
        at.lExps = at1.lExps;
    }
}

void lista_una_o_mas_exps(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    expresion(at1)
    {
        at.lExps.add(at1);
    }
    (
        < tC >
        { Attributes at2 = new Attributes(); }
        expresion(at2)
        { at.lExps.add(at2); }
    )*
}

void lista_cero_o_mas_asignables(Attributes at) :
{
    Attributes at1 = new Attributes();
}
{
    (lista_uno_o_mas_asignables(at1))?
    {
        at.type = at1.type;
        at.name = at1.name;
        at.beginColumn = at1.beginColumn;
        at.beginLine = at1.beginLine;
    }

}

void lista_uno_o_mas_asignables(Attributes at) :
{
    Attributes at1 = new Attributes();
    Attributes at2 = new Attributes();
}
{
    asignable(at1)
    {
        if (at1.type != Symbol.Types.CHAR && at1.type != Symbol.Types.INT) {
            errSem.deteccion("No se admite un argumento " + at1.type.name() + " en un 'read'", at1);
        }
        else {
            at.type = at1.type;
            at.name = at1.name;
            at.beginColumn = at1.beginColumn;
            at.beginLine = at1.beginLine;
        }
    }
    (
        < tC >
        asignable(at2) {
            if (at1.type != Symbol.Types.CHAR && at1.type != Symbol.Types.INT) {
                errSem.deteccion("No se admite un argumento " + at2.type.name() + " en un 'read'", at2);
            }
            else {
                at.type = at2.type;
                at.name = at2.name;
                at.beginColumn = at2.beginColumn;
                at.beginLine = at2.beginLine;
            }
        }
    )*
}
